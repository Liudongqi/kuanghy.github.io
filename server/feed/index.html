<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
  <title></title>
  <link href="/" rel="self"/>
  <link href=""/>
  <updated>2015-05-08T21:04:47+08:00</updated>
  <id></id>
  <author>
    <name></name>
    <email></email>
  </author>

  
  <entry>
    <title>你好，世界</title>
    <link href="/hello-world/"/>
    <updated>2015-05-05T00:00:00+08:00</updated>
    <id>/hello-world</id>
    <content type="html">&lt;p&gt;虽然毕业参加工作以来还不到一年的时间，但想想自己现在也已经是奔三的年纪。回想自己开始学编程时，已经18岁了。这岂不是远远的被别人落在了起跑线上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xixhp.com1.z0.glb.clouddn.com/schw.jpg&quot; alt=&quot;imge1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;世界上的第一个程序是 &lt;strong&gt;Hello World&lt;/strong&gt;。于是导致后来人在刚开始学习编程的时候，都以 &lt;strong&gt;Hello World&lt;/strong&gt; 开篇。以下这个笑话估计只有接触过编程的人才能看懂：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;某程序员退休后决定练习书法，于是重金购买文房四宝。一日，饭后突生雅兴，一番研墨拟纸，并点上上好檀香。定神片刻，泼墨挥毫，郑重地写下一行字：hello world！&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;我想，不懂编程的人是体会不到 &lt;strong&gt;Hello World&lt;/strong&gt; 的伟大的。&lt;/p&gt;

&lt;p&gt;我写的第一个程序是这个样子的：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class='ruby'&gt;// hello.c
#include &amp;lt;stdio.h&amp;gt;

int main(void)
{
  printf(&amp;quot;Hello world!\n&amp;quot;);
  
  return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;接着是这样子的：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class='cpp'&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

int main(void)
{
    cout &amp;lt;&amp;lt; &amp;quot;Hello world!&amp;quot; &amp;lt;&amp;lt; endl;

    return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;再接着是这样子的：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class='python'&gt;#! /usr/bin/env python
# -*- coding: utf-8 -*-

if __name__ == '__main__':
    print 'hello world'
    
# Script starts from here&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;然后是这样子的&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class='html'&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=UTF-8&amp;quot;&amp;gt;
        &amp;lt;meta name=&amp;quot;keywords&amp;quot; content=&amp;quot;HTML, CSS, XML, XHTML, JavaScript&amp;quot;&amp;gt;
        &amp;lt;meta name=&amp;quot;description&amp;quot; content=&amp;quot;Test on HTML and CSS&amp;quot;&amp;gt;
        &amp;lt;meta name=&amp;quot;author&amp;quot; content=&amp;quot;Huoty&amp;quot;&amp;gt;
        &amp;lt;meta http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;30&amp;quot;&amp;gt;
        &amp;lt;title&amp;gt;Web 设计&amp;lt;/title&amp;gt;
        &amp;lt;link rel=&amp;quot;shortcut icon&amp;quot; href=&amp;quot;/htmls/images/favicon.ico&amp;quot; type=&amp;quot;image/x-icon&amp;quot; /&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;h1&amp;gt;Hello world!&amp;lt;/h1&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;再然后是这样子的：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class='php'&gt;&amp;lt;?php  # Script -- php.php

/* 
 * 2015-05-05 12:49:49
 */

echo &amp;quot;Hello World!&amp;quot;;

?&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;再再然后是这样子的：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class='javascript'&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
    function button_clicked()
    {
        alert(&amp;quot;Hello world!&amp;quot;);
    }
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;啊，搞得好像我满脑子都是 &lt;strong&gt;Hello World&lt;/strong&gt; 似的。一下子罗列了不少的代码，就当我是在测试博客的代码语法效果吧。我不确定在以后的生涯中，我还会遇到多少的 &lt;strong&gt;Hello World&lt;/strong&gt;，我只觉得见到它，我有一些莫名的感觉。写到这里，突然不知道该说什么了，我明明记得我有很多话要说的。想要搭建独立博客的心郁积了很久，现在终于舒了一口气，当然是应该好好抒发一下心情的。其实，当一切平静下来的时候，很多东西都不在重要了。&lt;/p&gt;

&lt;p&gt;今天终于把博客的基本模型搭建完成，作为一名 &lt;strong&gt;Coder&lt;/strong&gt;，第一篇文章也就用了 &lt;strong&gt;Hello World&lt;/strong&gt; 开篇。&lt;/p&gt;

&lt;p&gt;你好，世界！！！&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>LibAhead for iOS - 在未越狱设备上修改三方APP的功能</title>
    <link href="/libahead/"/>
    <updated>2015-01-31T11:46:31+08:00</updated>
    <id>/libahead</id>
    <content type="html">&lt;p&gt;折腾了两个晚上，已搞定在未越狱 iOS 上向第三方 APP 注入 dylib 模块的方案！&lt;/p&gt;

&lt;p&gt;通过这个方案，使“微信去广告显IP删弧宠 for iOS ”成为可能（戏谑，但实现起来确实将比 Win32 下简单容易很多）。目前已实测在微信 iPhone 版中添加代码，强制开启“羊年春晚摇一摇”功能，不仅可以抢先体验提前穿越，还能随意控制原本随机摇出的各种功能（剧透：过年的时候微信摇一摇会有：新春红包、上传全家福到春晚、明信片、明星拜年、播放音乐、“甜蜜时光”、啥也没摇到、春晚节目单等功能：）。&lt;/p&gt;

&lt;p&gt;思路和十多年前的 AheadLib for Win32 创意方案一样。决定和 AheadLib 一样，做个自动化生成代码的工具，名字都想好了，LibAhead for iOS。宇宙依然，但青年不再，所以拖拖拉拉是难免的，哈&lt;/p&gt;

&lt;p&gt;针对特定 APP 写的 CydiaSubstrate dylib 模块，稍加处理即可集成到第三方 APP 里，并运行于未越狱的设备中。各种系统权限突破之类的还是老实点——干不了的；因为涉及修改 IPA 包，重新签名也是必须的。&lt;/p&gt;

&lt;p&gt;后续再把细节和工具慢慢补上……&lt;/p&gt;

&lt;p&gt;AppStore 之外（如蒲公英、同步推、快用、PP助手等）下载的 APP 都可能不是安全的——即使是未越狱的手机，基于以上功能完全可以在官方 APP 基础上做各种拦截和功能扩展。&lt;/p&gt;

&lt;p&gt;2015.02.06 更新：扯淡了，根本不需要转发，直接修改 Mach-O Load Command 表，插入 dylib 然后重新签名即可搞定一切，自动化工具已完成，未广泛测试：https://github.com/Yonsm/iPAFine&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>分析 Substrate 的 THUMB 函数 Hook 实现细节</title>
    <link href="/armhook/"/>
    <updated>2014-07-12T08:14:31+08:00</updated>
    <id>/armhook</id>
    <content type="html">&lt;p&gt;ARM 架构的 CPU 有 ARM 和 THUMB 执行态。&lt;/p&gt;

&lt;h4&gt;1. 先说 ARM 态（被Hook的函数）到 ARM 态（自己的替换函数）的 HOOK&lt;/h4&gt;

&lt;p&gt;  非常简单，没有看过 Substrate 的时候我就想到并验证过了（8 个字节）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  LDR PC, [PC， #-4]
  replacedFunctionAddress  ; 目标绝对地址（ARM 态的，偶数）
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. ARM 态到 THUMB 态的 HOOK&lt;/h4&gt;

&lt;p&gt;  和上面应该应该类似，只是   变成 replacedFunctionAddress + 1，转跳后自动切换到 THUMB 态。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  未验证（X！）
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3. THUMB 到 THUMB 态的 HOOK&lt;/h4&gt;

&lt;p&gt;  难理解的来了，经过实际测试发现&lt;strong&gt;下面的代码可以 HOOK 任意的函数（包括未导出的私有函数）&lt;/strong&gt;（注意，hookedFunctionAddress 如果是 THUMB 的，则需要 + 1——MD，在这栽了好长一段时间，感谢曾半仙）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  _MSHookFunction(hookedFunctionAddress + 1, (void *)replacedFunctionAddress, (void **)&amp;amp;pOriginalFunction); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  用以上 Substrate 的方法实现 THUMB 到 THUMB 的 HOOK 之后，我用 GDB 查看了一下内存，总共修改了12个字节，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  (gdb) x/3xw _mh_execute_header+0x1073E0
  0x15e3e0 &amp;lt;_mh_execute_header+1078240&amp;gt;:    0x46c04778  0xe51ff004  0x0029b6b9  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  反汇编代码（注意 THUMB 模式的 disas 地址要 +1 变成奇数）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  (gdb) disas _mh_execute_header+0x1073E1 _mh_execute_header+0x1073EC
  Dump of assembler code from 0x15e3e1 to 0x15e3ec:
  0x0015e3e1 &amp;lt;_mh_execute_header+1078241&amp;gt;:  bx  pc
  0x0015e3e3 &amp;lt;_mh_execute_header+1078243&amp;gt;:  nop         (mov r8, r8) 
  0x0015e3e5 &amp;lt;_mh_execute_header+1078245&amp;gt;:  blx 0x562e24 ; 请忽略
  0x0015e3e9 &amp;lt;_mh_execute_header+1078249&amp;gt;:  undefined ; 请忽略
  0x0015e3eb &amp;lt;_mh_execute_header+1078251&amp;gt;:  lsls    r1, r5, #0 ; 请忽略
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  第一条指令（C0 46）就是 THUMB 的 BX PC，第二条指令是 78 47 是 THUMB 的 NOP。后面的指令因为实际上是 BX 成 ARM 态了，所以请忽略。&lt;/p&gt;

&lt;p&gt;  BX PC 后实际上是转跳到了 ARM 态的 0x0015e3e4 地址，继续反汇编如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  (gdb) disas _mh_execute_header+0x1073E4 _mh_execute_header+0x1073EC
  Dump of assembler code from 0x15e3e4 to 0x15e3ec:
  0x0015e3e4 &amp;lt;_mh_execute_header+1078244&amp;gt;:  ldr pc, [pc, #-4]   ; 0x15e3e8 &amp;lt;_mh_execute_header+1078248&amp;gt;
  0x0015e3e8 &amp;lt;_mh_execute_header+1078248&amp;gt;:  strheq  r11, [r9], -r9 ; 这个就是和 replacedFunctionAddress + 1 了
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  可以看到从 0x0015e3e4 这里开始和上面提到的第一种情况（从ARM到THUMB）一样了。&lt;/p&gt;

&lt;p&gt;  补充：感谢 riusksk 做了一个直观图解，非常容易看明白：&lt;/p&gt;

&lt;p&gt;  &lt;img src=&quot;/assets/ThumbHook.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;4. 从 THUMB 到 ARM&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  你猜~~
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;关于转跳&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  * 如果操作数类型是imm, 那就是互换状态. ARM下到thumb, thumb下调用就到ARM；
  * 如果操作数是寄存器 根据低位地址，奇数为 THUMB，偶数为 ARM。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;知道了上述 HOOK 方法，再构造一个 pOriginalFunction，结合 Inject Dylib 的方法，就可以自己实现 Substrate 的完整功能了。&lt;/p&gt;

&lt;p&gt;（上面仅 3 是对 Substate 的 Hook 分析，其它是我 YY 的，不确定 Substrate 也是这样的实现，有兴趣的话可以自己反汇编/反编译 Substrate 去看实现细节）&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>Re-Symbolicate iOS Crash Report</title>
    <link href="/resymbolicate/"/>
    <updated>2014-06-25T01:31:42+08:00</updated>
    <id>/resymbolicate</id>
    <content type="html">&lt;p&gt;Xcode Organizer 连接手机看 Device Logs 的时候，有个 Re-Symbolicate 功能可以根据地址反查 Call Stack 中系统模块（如UIKit、CoreFoundation等）的符号信息。&lt;/p&gt;

&lt;p&gt;如果收到的是第三者设备提供过来的Crash Log，则无法使用该功能。使用以下命令可以实现同样的目的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer
  /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKitBase.framework/Versions/A/Resources/symbolicatecrash -v ~/CrashLog.crash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面提到的是反查系统模块的符号，下面这个则是根据崩溃地址和dSYM来反查自己程序模块中的符号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dwarfdump --lookup 0x00002712 -arch armv7 CrashTesting.app.dSYM/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦从地址中反查到了符号，将非常有助于分析Crash的原因。&lt;/p&gt;

&lt;p&gt;(2014.11.22 验证)&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>那些年，曾经做过的汉化</title>
    <link href="/hanzify/"/>
    <updated>2013-07-14T03:43:57+08:00</updated>
    <id>/hanzify</id>
    <content type="html">&lt;p&gt;现在已经没有汉化习惯了，整个分类删除掉了，记录一下历史，部分软件可以从&lt;a href=&quot;http://teach.hanzify.org/author/2520.html&quot;&gt;汉化新世纪&lt;/a&gt;下载：&lt;/p&gt;

&lt;p&gt;xScope 2.5 汉化版 – 设计、测量、校准和检查屏幕图形和布局的辅助工具
2011-08-12&lt;/p&gt;

&lt;p&gt;Araxis Merge 2011.4040 汉化版 – Mac 下好用的文件和文件夹比较工具
2011-08-09&lt;/p&gt;

&lt;p&gt;Changes 1.5.6 汉化版 – Mac 下的比较工具
2011-08-09&lt;/p&gt;

&lt;p&gt;MacDrive 8.0.5 简体中文汉化版
2010-05-07&lt;/p&gt;

&lt;p&gt;Palringo 简体中文绿色版 – 多功能的 IM 软件
2009-05-20&lt;/p&gt;

&lt;p&gt;IMPlus 5.67.1 汉化版
2009-04-26&lt;/p&gt;

&lt;p&gt;SKTracker，分析比对PPC注册表和文件系统变化的好工具
2008-11-19&lt;/p&gt;

&lt;p&gt;NewsBreak 2.1 汉化
2008-08-31&lt;/p&gt;

&lt;p&gt;TaskMgr 3.1 汉化 – PPC 中强大的窗口进程等系统剖析工具
2008-08-31&lt;/p&gt;

&lt;p&gt;PocketCalc 2.2.1 汉化版
2008-08-30&lt;/p&gt;

&lt;p&gt;HiCalc 2.5.1- 功能最强大、界面最漂亮的计算器
2008-08-29&lt;/p&gt;

&lt;p&gt;Resco Explorer 2008 7.0.5 完美汉化
2008-08-28&lt;/p&gt;

&lt;p&gt;Virtual Drive Manager 1.3.1 汉化修正
2008-08-26&lt;/p&gt;

&lt;p&gt;GPS Pack
2008-08-26&lt;/p&gt;

&lt;p&gt;RESCO Explorer 2007 6.16 简体中文化版本
2007-10-13&lt;/p&gt;

&lt;p&gt;Kevtris 2.0 – 最漂亮、最好玩的而罗斯方块
2007-04-12&lt;/p&gt;

&lt;p&gt;PIEPlus 2.1 RC2 最完美汉化版 – PocketIE 增强工具
2006-08-17&lt;/p&gt;

&lt;p&gt;WM5torage 1.7 汉化版 – 把 Windows Mobile 5.0 当优盘用
2006-08-17&lt;/p&gt;

&lt;p&gt;Kevtris 1.1 汉化版- Windows Mobile 最好玩的俄罗斯方块
2006-04-04&lt;/p&gt;

&lt;p&gt;GraphEdit – DirectShow Graph 图表工具
2005-09-03&lt;/p&gt;

&lt;p&gt;Kevtris 1.0 汉化版- Smartphone上非常好玩的俄罗斯方块
2005-06-20&lt;/p&gt;

&lt;p&gt;BetaPlayer 0.096/0.5 完整汉化版
2005-06-10&lt;/p&gt;

&lt;p&gt;Resco System Toys 1.20 汉化补丁
2005-05-22&lt;/p&gt;

&lt;p&gt;Resco Photo Viewer 5.20 汉化补丁
2005-05-22&lt;/p&gt;

&lt;p&gt;Resco Explorer 2003 5.00 汉化补丁
2005-05-22&lt;/p&gt;

&lt;p&gt;Dependency Walker 2.1.3790 汉化版
2005-03-13&lt;/p&gt;

&lt;p&gt;ExamDiff Pro 3.3 汉化版
2005-02-22&lt;/p&gt;

&lt;p&gt;SourceStyler C++ 汉化版&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>博客迁移到 Jekyll @ GitHub - 你也可以fork在GitHub建站哦</title>
    <link href="/hello-jekyll/"/>
    <updated>2013-07-14T00:00:00+08:00</updated>
    <id>/hello-jekyll</id>
    <content type="html">&lt;p&gt;在 Wopus 上的博客空间快到期了，我终于下决心迁移到 GitHub 上。好处就不多说了，看看&lt;a href=&quot;http://www.besteric.com/2013/05/08/migrate-wordpress-to-jekyll/&quot;&gt;别人怎么说 Jekyll @ GitHub&lt;/a&gt;吧。&lt;/p&gt;

&lt;p&gt;GitHub上找了个&lt;a href=&quot;http://webfrogs.me/2012/12/20/use-jekyll/&quot;&gt;模板&lt;/a&gt;，花了一整天折腾修改，分类、链接、评论、附件等终于都完美了，搜索引擎优化、站内搜索等还没完成。如果需要可以在 &lt;a href=&quot;http://www.github.com/Yonsm&quot;&gt;GitHub&lt;/a&gt; 上参考我的这个 &lt;a href=&quot;http://www.github.com/Yonsm/NET&quot;&gt;博客的完整代码&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;回看一下博客建立到现在快 9 年了，从刚开始的把博客当微博用，到中期的勤奋“耕耘”，再对比一下今年的7个月快过去了才 3 篇不像样的文章，今昔非比。这次迁移重新整理了博客，文章数目从 530 篇缩减到 250 篇。希望这次变换博客空间和引擎是个契机（好吧，是借口），接下来的时间里能多产出点东西。Idea 有很多，能不能出来就不知道了。&lt;/p&gt;

&lt;p&gt;刚开始使用 Markdown 写东西，很不错。语法高亮可以使用 &lt;a href=&quot;http://pygments.org/&quot;&gt;Pygments&lt;/a&gt; ，&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Liquid-Extensions&quot;&gt;使用介绍在此&lt;/a&gt;。例子效果如下：&lt;/p&gt;

&lt;div&gt;
  &lt;pre&gt;&lt;code class='objc'&gt;void FixWordPressExportedXML(NSString *src, NSString *dst)
{
    NSMutableString *data = [NSMutableString stringWithContentsOfFile:src encoding:NSUTF8StringEncoding error:nil];
    if (data)
    {
        for (NSInteger i = data.length - 1; i &amp;gt;= 0; i--)
        {
            unichar c = [data characterAtIndex:i];
            if (c &amp;lt; 0x20 &amp;amp;&amp;amp; c != 9 &amp;amp;&amp;amp; c != '\r' &amp;amp;&amp;amp; c != '\n')
            {
                [data replaceCharactersInRange:NSMakeRange(i, 1) withString:@&amp;quot; &amp;quot;];
            }
        }
        [data replaceOccurrencesOfString:@&amp;quot;&amp;amp;nbsp;&amp;quot; withString:@&amp;quot; &amp;quot; options:nil range:NSMakeRange(0, data.length)];
        [data writeToFile:dst atomically:NO encoding:NSUTF8StringEncoding error:nil];
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;



</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>[转载]如何制作自己的 Fusion Drive 硬盘</title>
    <link href="/how-to-make-fusion-drive/"/>
    <updated>2013-01-14T21:19:01+08:00</updated>
    <id>/how-to-make-fusion-drive</id>
    <content type="html">&lt;p&gt;Fusion Drive的性能号称能直追纯SSD，如果有2010年的27' iMac，或者2011 2012的iMac 21'/27'或者MacBook Pro替换光驱上128G SSD，弄成Fusion Drive 应该是一个非常不错的方案。直接上原文吧：&lt;a href=&quot;http://appleuser.com/2012/11/30/fusiondrive/&quot;&gt;http://appleuser.com/2012/11/30/fusiondrive/&lt;/a&gt;&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>劫持MLB.TV和WSJ Live和预告片，打造自己的Apple TV本地媒体浏览器</title>
    <link href="/atvme/"/>
    <updated>2012-11-15T08:28:19+08:00</updated>
    <id>/atvme</id>
    <content type="html">&lt;h1&gt;Apple TV Media Explorer&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;升级您的 AppleTV 到最新版本固件。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在设置中把区域改成香港（或美国），这样主页上你可以看到好些图标。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;劫持DNS，有两种方法，请任选其一：
1).如果您的路由器支持DNSMasQ，可以在路由器上配置DNS劫持（192.168.1.9 换成你的 HTTP 服务器的 IP 地址，IP 地址仅举例，自行替换）：&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;address=/www.marketwatch.com/192.168.1.9&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;address=/trailers.apple.com/180.153.225.136&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;第二行为劫持预告片到 TT 的服务器（大量在线视频内容），非必须，但强烈推荐。&lt;/p&gt;

&lt;p&gt;2).如果你不会弄DNS服务器，可以用我提供的，在AppleTV上设置DNS为117.41.182.103，这样的话http服务器地址必须是 192.168.1.9。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;搭建HTTP服务，确保 http://192.168.1.9 能访问；HTTP 弄好后，需要开启文件列表功能（dir listing），这样我们才能以让ATV把上面的媒体文件列出来播放。
1). Tomato 能用的lighttpd精简版可以从我这里自行提取：http://hdweb.googlecode.com/svn/ROUTER，已开启dir listing）
2). My Book Live 开启dir listing，参考TT的帖子：http://bbs.weiphone.com/read-htm-tid-5484774.html，其实可以改进一下，编辑 wdnas文件，里面var/www的-Indexes前面的减号去掉，全局都支持dir listing了，不用创建.htaccess文件了。
3). 其他NAS请自行想办法搭建http服务器。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把附件下载下来，解压放到http服务器根目录下（注意是http://192.168.1.9/api-video，目录不要多了，也不要少了）。源代码在 https://github.com/Yonsm/ATVME 上，需要尝鲜的可以去哪里随时看看有什么更新。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改里面的index.xml文件，指向把url指向你的媒体文件的http url（能列出你的媒体文件的），目前index.xml是TAB页面，有5个版面：照片、视频、音乐、下载、设置。如果你也正好用我的文件路径（比如/media/Pictures）那就不用改了。注意每个URL最后的“/”是必须的，不要省略。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;打开ATV，看看 WSJ Live，把你的文件都列出来了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;0). 常规使用：视频、音乐直接点击播放，照片文件夹则以平铺方式呈现，支持幻灯片显示，非常完美。
1). 支持缩略图：如果有“文件或文件夹名称.thumb.jpg”（或“.thumb.文件或文件夹名称.jpg”）存在，则会自动用作缩略图。
2). 外挂SRT字幕：如果有“文件名.srt”存在（注意扩展名也需要，如“A.mp4.srt”），则会显示外挂字幕。
3). 支持连续播放：播放视频和音乐时如果按播放键（Play），完成后会自动播放下一个；如果按选择键（Select/Enter），则播放完成后不会自动播放下一个。
4). 显示简要信息：播放过程中按向上方向键两次，则会显示URL信息和播放列表剩余的项目数。（BTW：播放过程中按向下一次可以分段Seek，ATV内置的功能）。&lt;/p&gt;

&lt;p&gt;更新历史：
  1.0  第一个实现版本。
  1.2  支持SRT外挂字幕和连续播放。
  1.3  支持文件夹优先显示；缩略图url不再要求前置。
  2.0 支持TT的MKV播放方案，支持自动生成缩略图（需要ffmpeg最新版，需要开启任意目录cgi支持，步骤稍复杂，教程后面再整理），代码在SVN上。&lt;/p&gt;

&lt;p&gt;持续更新中，详细步骤和说明请移步看2楼的详细帖子。：http://bbs.weiphone.com/read-htm-tid-5460032.html&lt;/p&gt;

&lt;p&gt;MKV方案请看TT的论坛：http://www.ottnt.com/forum.php&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>PPC 中打开通话记录</title>
    <link href="/open-call-log-in-ppc/"/>
    <updated>2009-04-03T13:41:28+08:00</updated>
    <id>/open-call-log-in-ppc</id>
    <content type="html">&lt;p&gt;SP 中有一个exe用来打开通话记录，万恶的WM竟然弄得PPC上不一样。经分析找到一个简洁的方法，可以在PPC中打开通话记录界面，代码如下：&lt;/p&gt;

&lt;p&gt;if (HWND hWnd = FindWindow(TEXT(&quot;MSCProg&quot;), NULL))&lt;br/&gt;
{&lt;br/&gt;
 PostMessage(hWnd, 0x801A, 0, 0);&lt;br/&gt;
}&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;&lt;/p&gt;

&lt;p&gt;又他妈的是私有的消息，做出这么垃圾的系统垃圾的设计，WM 的设计者真该去S!&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>换用杭州联通宽带快一个月了</title>
    <link href="/using-china-unicom-network-for-a-month/"/>
    <updated>2009-04-02T13:58:15+08:00</updated>
    <id>/using-china-unicom-network-for-a-month</id>
    <content type="html">&lt;p&gt;以前用电信ADSL将近7年了，一直听说“网通”没电信的ADSL好。今年过了年来了之后，本想继续包2年ADSL，到要确认的时候竟然又出霸王条款，无语的细节就不说了&lt;!-- more --&gt;（TIA! 有些事情想不通的时候，想想这时天朝 ，就想通了——This Is China!）&lt;/p&gt;

&lt;p&gt;一不小心看到小区内的广告，“原中国网通”“现联通宽带”促销云云，打电话到10010竟然说可能是下面搞得活动，不清楚。后来谨慎确认了一下，确有其事，于是装了，980 元 = 2M ADSL 14个月+ 150购物卡 + 送一个联通的卡（可用一年不用充值，但没对我没啥用反正）。火星了一把的是，杭州网通竟然不是常规意义上的“网通”，跟中国网通不搭噶的东西，还好中国网通现在也并入联通了，以后就说联通宽带吧。&lt;/p&gt;

&lt;p&gt;换用杭州联通宽带快一个月了，基本感觉满意。下载速度基本能保证180-200K（迅雷，修在MS网站上的东西速度220K），就是访问一些电信的网站好不到哪里去，到某些电信服务器的响应速度比较慢，据说游戏的也会有点卡的，反正不玩游戏，下载速度才是王道。&lt;/p&gt;

&lt;p&gt;另外，从服务来说，联通也够乱的，就这情形，估计就是给了WCDMA的牌照，也好不到哪里去。&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>PPC 中向其它进程中插入DLL的方法及通用代码</title>
    <link href="/insert-a-dll-into-another-process-in-ppc/"/>
    <updated>2009-03-24T11:43:29+08:00</updated>
    <id>/insert-a-dll-into-another-process-in-ppc</id>
    <content type="html">&lt;p&gt;大家都知道 PC 中写破解补丁的其中一个方法是 Loader，通常的做法是CreateProcess后用CreateRemoteThread来Load我们的DLL。但这个方法在WM中显然不可行（压根没这个API）。&lt;/p&gt;

&lt;p&gt;WM中要在指定的进程中执行我们的代码，可以用一个未公开的 PerformCallBack4 API。利用这个API，可以在目标进程中执行我们的代码。&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;首先声明：这个方法仅对于SP2003及所有PPC有效，对于SP5及其以上系统非常可能失效，因为SP的权限要求比PPC高。为了在SP5/6中具备同样的功能，需要做一系列非常复杂的操作，我也已经琢磨出相关的方案可通用的代码，说起来比较啰嗦，暂且按下不表，以后再叙吧。&lt;/p&gt;

&lt;p&gt;废话不多说，直接看代码：&lt;br/&gt;
 STATIC HMODULE RemoteLoadLibrary(HANDLE hProcess, PCTSTR ptzPath)&lt;br/&gt;
 {&lt;br/&gt;
   BOOL bMode = SetKMode(TRUE);&lt;br/&gt;
   DWORD dwPerm = SetProcPermissions(0xFFFFFFFF);&lt;/p&gt;

&lt;p&gt;   CALLBACKINFO ci;&lt;br/&gt;
   ci.hProc= hProcess;&lt;br/&gt;
   ci.pFunc = (FARPROC) MapPtrToProcess(GetProcAddress(GetModuleHandle(TEXT(&quot;COREDLL&quot;)), TEXT(&quot;LoadLibraryW&quot;)), hProcess);;&lt;br/&gt;
   ci.pvArg0 = MapPtrToProcess((PVOID) ptzPath, GetCurrentProcess());&lt;br/&gt;
   HMODULE hModule = (HMODULE) PerformCallBack4(&amp;ci;, 0, 0, 0);&lt;/p&gt;

&lt;p&gt;   SetKMode(bMode);&lt;br/&gt;
   SetProcPermissions(dwPerm);&lt;br/&gt;
   return hModule;&lt;br/&gt;
 }&lt;/p&gt;

&lt;p&gt;上面的函数中，首先设置权限，然后映射LoadLibraryW的地址到目标进程，然后在目标进程中执行LoadLibraryW装载我们的DLL。OK，既然我们的DLL都被Load到目标进城了，要干什么，请随意（一般来说，DllMain函数中创建一个线程后，立即返回。在线程中做你想做的事）。&lt;/p&gt;

&lt;p&gt;使用例子（执行一个目标进程并运行直接运行一个EXE（如果没运行，运行了则直接操作）并运行我们的DLL）：&lt;/p&gt;

&lt;p&gt; HMODULE hModule = CCodeInj::RemoteLoadLibrary(TEXT(&quot;cprog.exe&quot;), tzDllPath);&lt;br/&gt;
 if (hModule == NULL)&lt;br/&gt;
 {&lt;br/&gt;
   Sleep(500);&lt;br/&gt;
   PROCESS_INFORMATION pi;&lt;br/&gt;
   if (CreateProcess(TEXT(&quot;cprog.exe&quot;),, NULL, NULL, NULL, FALSE, 0, NULL, NULL, NULL, π))&lt;br/&gt;
   {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Sleep(2000);  

 hModule = CCodeInj::RemoteLoadLibrary(pi.hProcess, tzDllPath);  

 CloseHandle(pi.hThread);  
 CloseHandle(pi.hProcess);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   }&lt;br/&gt;
 }&lt;/p&gt;

&lt;p&gt;为了更好地使用，我提供了更多的功能，请参看附件。&lt;/p&gt;

&lt;p&gt;下载附件请到：http://bbs.pediy.com/showthread.php?p=595544#post595544&lt;br/&gt;
或者来信至 Yonsm@msn.cm&lt;/p&gt;

&lt;p&gt;1.你得准备一个 DLL，假设是 MyHook.dll&lt;br/&gt;
2 另有一个代码执行的空间（无论是EXE还是DLL，也可以在 MyHook.dll），然后在这个代码空间执行：RemoteLoadLibrary&lt;br/&gt;
  指定远程进程（比如 cprog.exe，就是你要插入的进程），和DLL路径（就是MyHook.dll的路径）&lt;br/&gt;
3. 那么，RemoteLoadLibrary就会让 crpog.exe 来 LoadLibrary(MyHook.dll)，你在MyHook.dll里面就可以做你想做的事。&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>服务器惊魂……</title>
    <link href="/frightened-the-server/"/>
    <updated>2009-03-19T12:30:39+08:00</updated>
    <id>/frightened-the-server</id>
    <content type="html">&lt;p&gt;好久没写过日志或做点东西了，最近忙了很多事情，按下不表……&lt;/p&gt;

&lt;p&gt;今天为了尝试一下VPN，在服务器上尝试装了好几个VPN软件，气壮SoftEther配置Internet共享的时候，服务器竟然挂掉了。晕死！&lt;/p&gt;

&lt;p&gt;赶紧找Yicho恢复，辗转N久，终于恢复正常了。谨慎作风忘了，大胆胡乱操作，该S！&lt;/p&gt;

&lt;p&gt;宕机日志，仅以此文以记之……&lt;/p&gt;

&lt;p&gt;其实……Windows 本身的 VPN 就很好用。也可以改端口。&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>败入一个ASUS P527</title>
    <link href="/buy-an-asus-p527/"/>
    <updated>2008-01-23T01:25:52+08:00</updated>
    <id>/buy-an-asus-p527</id>
    <content type="html">&lt;p&gt;买了个新上市不久的 ASUS P527，总的来说还行，但不超频速度比较慢，暂时还是繁体中文的ROM，用起来不太习惯。&lt;/p&gt;

&lt;p&gt;感谢老猫（&lt;a href=&quot;http://www.pdaclan.com/&quot;&gt;www.pdaclan.com&lt;/a&gt;）和TNG（淘宝网店&lt;!-- more --&gt;：&lt;a href=&quot;http://store.taobao.com/shop/view_shop.htm?user_id=764c31f50fbd4014b8298b76bdfc1d2f&quot;&gt;http://store.taobao.com/shop/view_shop.htm?user_id=764c31f50fbd4014b8298b76bdfc1d2f&lt;/a&gt;）。TNG是值得信任的卖家，如果大家有需要可以在他这里购买智能手机和相关物品（不算是广告：）。&lt;/p&gt;

&lt;p&gt;过段时间空闲且可行的话将会尝试 P527 的ROM，一定会是最好用的一个：）&lt;/p&gt;

&lt;p&gt;不再更新 830 的ROM了，2007.10.28 将是最后一个 WM5 ROM，抱歉一直没有出新的 WM6 ROM，确实是个人空闲时间和精力有限。&lt;/p&gt;

&lt;p&gt;2008.1.25 加注：目前强烈不推荐大家购买 ASUS P527，及其不稳定，各方面都有很多BUG，WIFI、GPS、电话功能等等都有很多不稳定的地方，过段时间再看。&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>长途奔袭，千里归家</title>
    <link href="/long-distance-driving/"/>
    <updated>2008-01-02T14:38:16+08:00</updated>
    <id>/long-distance-driving</id>
    <content type="html">&lt;p&gt;昨天从杭州回老家&lt;!-- more --&gt;赣州定南（江西最南边的一个县），距离杭州1050公里，全程高速。第一次开车走这么远，很多老司机都说新手不要走这么久的长途，于是我决定如果累了就在中途南昌睡一晚第二天再走。总的下来感觉还行，还是年轻有体力，中途休息站多次休息，基本上没有什么疲劳感，总共耗时12个小时整，行程1060公里，路费120+300=420，油费400元左右应该能走下来（我的小毛驴高尔1.6，油有剩余，估计不完全准确）。这几天比较忙，6号回杭州后再整理一下此次来回行程的总结……待续——感谢“美帝”的GPS，还是特别非常以及很有用的……&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>[调查]你的手机是什么系统，在 CeleDial 吗?</title>
    <link href="/investigation-for-celedial/"/>
    <updated>2007-11-02T17:10:52+08:00</updated>
    <id>/investigation-for-celedial</id>
    <content type="html">&lt;p&gt;调查已结束，下面是结果：&lt;/p&gt;

&lt;p&gt;■ WM6PPC，使用 CeleDial: 175&lt;br/&gt;
■ WM6PPC，不用 CeleDial: 72&lt;br/&gt;
■ WM5PPC，使用 CeleDial: 146&lt;br/&gt;
■ WM5PPC，不用 CeleDial: 69&lt;br/&gt;
■ PPC2003，使用 CeleDial: 73&lt;br/&gt;
■ PPC2003，不用 CeleDial: 49&lt;br/&gt;
■ 我是 Smartphone 用户: 109&lt;br/&gt;
■ 我不是 WinMobile 用户: 52&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;&lt;/p&gt;

&lt;p&gt;客观说，WM 5.0 PPC/PPC 2003 中文用户，强烈推荐使用 CeleDial，必备杀手应用程序：）&lt;br/&gt;
客观说，WM6.0 PPC 请自行决定。&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>枚举窗口假死和枚举进程失败的解决方案</title>
    <link href="/solution-for-enumeration-windows/"/>
    <updated>2007-10-24T12:05:28+08:00</updated>
    <id>/solution-for-enumeration-windows</id>
    <content type="html">&lt;p&gt;CeleTask 枚举任务窗口时，如果其他程序停止响应，可能会出现假死状态。枚举进程的部分如果内存过少（或者某些程序开着），会出现无法成功的情况。今天经过仔细分析，终于找到了终极解决方案。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;枚举窗口没有问题，问题出在获取窗口标题上，WM_GETTEXT/GetWindowText 均会造成程序等待，如果其他进程窗口假死，则CeleTask也等着。解决方法是使用以下方法获取标题，经试验完美解决：&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;SendMessageTimeout(hWnd, WM_GETTEXT, MAX_NAME, (LPARAM) &amp;tzStr;, 0, 100, &amp;dwRet;);&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;进程枚举失败的部分，经过反汇编分析 SKTools 的代码，发现一个 Undocumented 的 Flag: 0x40000000，把这个 标记设置在 CreateToolhelpSnapshot 上，就可以了。经查确认，此标志无文档支持，但经测试以完美解决。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;市面上所有的窗口枚举和进程枚举软件均存在此问题（SKTools的进程功能除外），包括QuickMenu等。现已解决，分享在此。&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;基于以上结论， CeleTask 将在近期更新版本 2.4 ，除了解决上述问题，还将加入其他功能（导入注册表文件等）。Smartphone 用户可留意本 BLOG 的更新信息。&lt;/p&gt;

&lt;p&gt;2007.10.27 更新：声明如下未公开的函数，代替GetWindowText使用，效果最佳，无阻赛问题，速度快，P/PPC 2003/5.0/6.0 均适用：&lt;/p&gt;

&lt;p&gt;extern &quot;C&quot; INT WINAPI GetWindowTextWDirect(HWND hWnd, PWSTR pwzStr, INT nMaxCount);&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>在 Visual C++ 中使用内联汇编</title>
    <link href="/inline-assembler-in-vc/"/>
    <updated>2006-02-06T16:37:43+08:00</updated>
    <id>/inline-assembler-in-vc</id>
    <content type="html">&lt;p&gt;一、 优点&lt;/p&gt;

&lt;p&gt;使用内联汇编可以在 C/C++ 代码中嵌入汇编语言指令，而且不需要额外的汇编和连接步骤。在 Visual C++ 中，内联汇编是内置的编译器，因此不需要配置诸如 MASM 一类的独立汇编工具。这里，我们就以 Visual Studio .NET 2003 为背景，介绍在 Visual C++ 中使用内联汇的相关知识（如果是早期的版本，可能会有些许出入）。&lt;/p&gt;

&lt;p&gt;内联汇编代码可以使用 C/C++ 变量和函数，因此它能非常容易地整合到 C/C++ 代码中。它能做一些对于单独使用 C/C++ 来说非常笨重或不可能完成的任务。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;&lt;/p&gt;

&lt;p&gt;内联汇编的用途包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用汇编语言编写特定的函数；&lt;/li&gt;
&lt;li&gt;编写对速度要求非常较高的代码；&lt;/li&gt;
&lt;li&gt;在设备驱动程序中直接访问硬件；&lt;/li&gt;
&lt;li&gt;编写 naked 函数的初始化和结束代码。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;二、 关键字&lt;/p&gt;

&lt;p&gt;使用内联汇编要用到 __asm 关键字，它可以出现在任何允许 C/C++ 语句出现的地方。我们来看一些例子：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;简单的 __asm 块：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;__asm&lt;br/&gt;
&amp;leftsign;&lt;br/&gt;
MOV AL, 2&lt;br/&gt;
MOV DX, 0xD007&lt;br/&gt;
OUT AL, DX&lt;br/&gt;
&amp;rightsign;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在每条汇编指令之前加 __asm 关键字：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;asm MOV AL, 2&lt;br/&gt;
&lt;/strong&gt;asm MOV DX, 0xD007&lt;br/&gt;
__asm OUT AL, DX&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;因为 __asm 关键字是语句分隔符，所以可以把多条汇编指令放在同一行：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;asm MOV AL, 2 &lt;/strong&gt;asm MOV DX, 0xD007 __asm OUT AL, DX&lt;/p&gt;

&lt;p&gt;显然，第一种方法与 C/C++ 的风格很一致，并且把汇编代码和 C/C++ 代码清楚地分开，还避免了重复输入 __asm 关键字，因此推荐使用第一种方法。&lt;/p&gt;

&lt;p&gt;不像在 C/C++ 中的&quot;&amp;leftsign;&amp;rightsign;&quot;，&lt;strong&gt;asm 块的&quot;&amp;leftsign;&amp;rightsign;&quot;不会影响 C/C++ 变量的作用范围。同时，&lt;/strong&gt;asm 块可以嵌套，而且嵌套也不会影响变量的作用范围。&lt;/p&gt;

&lt;p&gt;为了与低版本的 Visual C++ 兼容，_asm 和 &lt;strong&gt;asm 具有相同的意义。另外，Visual C++ 支持标准 C++ 的 asm 关键字，但是它不会生成任何指令，它的作用仅限于使编译器不会出现编译错误。要使用内联汇编，必须使用 &lt;/strong&gt;asm 而不是 asm 关键字。&lt;/p&gt;

&lt;p&gt;三、 汇编语言&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;指令集&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;内联汇编支持 Intel Pentium 4 和 AMD Athlon 的所有指令。更多其它处理器的指令可以通过 &lt;em&gt;EMIT 伪指令来创建（&lt;/em&gt;EMIT 伪指令说明见下文）。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;MASM 表达式&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;在内联汇编代码中，可以使用所有的 MASM 表达式（MASM 表达式是指用来计算一个数值或一个地址的操作符和操作数的组合）。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数据指示符和操作符&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;虽然 &lt;strong&gt;asm 块中允许使用 C/C++ 的数据类型和对象，但它不能使用 MASM 指示符和操作符来定义数据对象。这里特别指出，&lt;/strong&gt;asm 块中不允许 MASM 中的定义指示符（DB、DW、DD、DQ、DT 和 DF），也不允许使用 DUP 和 THIS 操作符。MASM 中的结构和记录也不再有效，内联汇编不接受 STRUC、RECORD、WIDTH 或者 MASK。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;EVEN 和 ALIGN 指示符&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;尽管内联汇编不支持大多数 MASM 指示符，但它支持 EVEN 和 ALIGN。当需要的时候，这些指示符在汇编代码里面加入 NOP 指令（空操作）使标号对齐到特定边界。这样可以使某些处理器取指令时具有更高的效率。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;MASM 宏指示符&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;内联汇编不是宏汇编，不能使用 MASM 宏指示符（MACRO、REPT、IRC、IRP 和 ENDM）和宏操作符（&amp;lt;&gt;、!、&amp;amp;、% 和 .TYPE）。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;段&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;必须使用寄存器而不是名称来指明段（段名称&quot;_TEXT&quot;是无效的）。并且，段跨越必须显式地说明，如 ES:[EBX]。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;类型和变量大小&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;在内联汇编中，可以用 LENGTH、SIZE 和 TYPE 来获取 C/C++ 变量和类型的大大小。&lt;br/&gt;
* LENGTH 操作符用来取得 C/C++ 中数组的元素个数（如果不是一个数组，则结果为 1）。&lt;br/&gt;
* SIZE 操作符可以获取 C/C++ 变量的大小（一个变量的大小是 LENGTH 和 TYPE 的乘积）。&lt;br/&gt;
* TYPE 操作符可以返回 C/C++ 类型和变量的大小（如果变量是一个数组，它得到的是数组中单个元素的大小）。&lt;/p&gt;

&lt;p&gt;例如，程序中定义了一个 8 维的整数型变量：&lt;/p&gt;

&lt;p&gt;int iArray[8];&lt;/p&gt;

&lt;p&gt;下面是 C 和汇编表达式中得到的 iArray 及其元素的相关值：&lt;/p&gt;

&lt;p&gt;__asm C Size&lt;/p&gt;

&lt;p&gt;LENGTH iArray sizeof(iArray)/sizeof(iArray[0]) 8&lt;br/&gt;
SIZE iArray sizeof(iArray) 32&lt;br/&gt;
TYPE iArray sizeof(iArray[0]) 4&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;注释&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;内联汇编中可以使用汇编语言的注释，即&quot;;&quot;。例如：&lt;/p&gt;

&lt;p&gt;__asm MOV EAX, OFFSET pbBuff ; Load address of pbBuff&lt;/p&gt;

&lt;p&gt;因为 C/C++ 宏将会展开到一个逻辑行中，为了避免在宏中使用汇编语言注释带来的混乱，内联汇编也允许使用 C/C++ 风格的注释。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;_EMIT 伪指令&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;em&gt;EMIT 伪指令相当于 MASM 中的 DB，但是 &lt;/em&gt;EMIT 一次只能在当前代码段（.text 段）中定义一个字节。例如：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;_asm&lt;br/&gt;
&amp;leftsign;&lt;br/&gt;
JMP &lt;/em&gt;CodeLabel&lt;/p&gt;

&lt;p&gt;&lt;em&gt;EMIT 0x00 ; 定义混合在代码段的数据&lt;br/&gt;
&lt;/em&gt;EMIT 0x01&lt;/p&gt;

&lt;p&gt;&lt;em&gt;CodeLabel: ; 这里是代码&lt;br/&gt;
&lt;/em&gt;EMIT 0x90 ; NOP指令&lt;br/&gt;
&amp;rightsign;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;寄存器使用&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;一般来说，不能假定某个寄存器在 &lt;strong&gt;asm 块开始的时候有已知的值。寄存器的值将不能保证会从 &lt;/strong&gt;asm 块保留到另外一个 __asm 块中。&lt;/p&gt;

&lt;p&gt;如果一个函数声明为 &lt;strong&gt;fastcall 调用方式，则其参数将通过寄存器而不是堆栈来传递。这将会使 &lt;/strong&gt;asm 块产生问题，因为函数无法被告知哪个参数在哪个寄存器中。如果函数接收了 EAX 中的参数并立即储存一个值到 EAX 中的话，原来的参数将丢失掉。另外，在所有声明为 &lt;strong&gt;fastcall 的函数中，ECX 寄存器是必须一直保留的。为了避免以上的冲突，包含 &lt;/strong&gt;asm 块的函数不要声明为 __fastcall 调用方式。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提示：如果使用 EAX、EBX、ECX、EDX、ESI 和 EDI 寄存器，你不需要保存它。但如果你用到了 DS、SS、SP、BP 和标志寄存器，那就应该用 PUSH 保存这些寄存器。&lt;/li&gt;
&lt;li&gt;提示：如果程序中改变了用于 STD 和 CLD 的方向标志，必须将其恢复到原来的值。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;四、 使用 C/C++ 元素&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;可用的 C/C++ 元素&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;C/C++ 与汇编语言可以混合使用，在内联汇编中可以使用 C/C++ 变量以及很多其它的 C/C++ 元素，包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;符号，包括标号、变量和函数名；&lt;/li&gt;
&lt;li&gt;常量，包括符号常量和枚举型成员；&lt;/li&gt;
&lt;li&gt;宏定义和预处理指示符；&lt;/li&gt;
&lt;li&gt;注释，包括&quot;/**/&quot;和&quot;//&quot;；&lt;/li&gt;
&lt;li&gt;类型名，包括所有 MASM 中合法的类型；&lt;/li&gt;
&lt;li&gt;typedef 名称，通常使用 PTR 和 TYPE 操作符，或者使用指定的的结构或枚举成员。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在内联汇编中，可以使用 C/C++ 或汇编语言的基数计数法。例如，0x100 和 100H 是相等的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;操作符使用&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;内联汇&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>启用顶级域名 Yonsm.NET</title>
    <link href="/register-yonsm-net/"/>
    <updated>2006-01-18T16:00:00+08:00</updated>
    <id>/register-yonsm-net</id>
    <content type="html">&lt;p&gt;启用顶级域名 Yonsm.NET，这下是真正 Yonsm.NET 了。当然，也可以用 &lt;a href=&quot;/&quot;&gt;www.Yonsm.net&lt;/a&gt; 访问我的BLOG。&lt;/p&gt;

&lt;p&gt;欢迎&lt;a href=&quot;javascript:window.external.AddFavorite(&quot; title=&quot;http://www.yonsm.net',%20'Yonsm.NET&quot;&gt;收藏&lt;/a&gt;;)新网址到你的收藏夹。另外，请链接了原BLOG网址的朋友更新你网站上的链接，谢谢！&lt;/p&gt;

&lt;p&gt;这个域名是 vBin 帮忙搞的，60 元一年，如果你需要域名或虚拟主机服务，不妨联系他：&lt;a href=&quot;mailto:vbin@163.net&quot;&gt;vbin@163.net&lt;/a&gt;&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>年年岁岁车相似，岁岁年年票不同</title>
    <link href="/no-train-ticket/"/>
    <updated>2006-01-18T11:27:57+08:00</updated>
    <id>/no-train-ticket</id>
    <content type="html">&lt;p&gt;不同点是是：&lt;strong&gt;一年更比一年难买&lt;/strong&gt;！XX部副部长竟然还厚颜无耻的说这种情况在2010年将会有所改观——做事风格不变，铁路公路再长两倍，飞机再翻N翻，也是枉然！&lt;/p&gt;

&lt;p&gt;以下文字转载自：http://news.phoenixtv.com/phoenixtv/83887291180777472/20060116/730448.shtml&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不要轻易说“春运只能遭罪” &lt;/strong&gt;
2006年01月16日 10:04    来源：南方都市报&lt;/p&gt;

&lt;p&gt;2006年的春运于昨日拉开了帷幕。几乎是每年春运的拷贝版，打开媒体，展示给我们的是一幕幕让人惊心的镜头：火车站里人山人海，订票口前长队蜿蜒，有人让票贩子骗走了订票款，有人怕挤不到厕所竟然准备好了纸尿裤……&lt;/p&gt;

&lt;p&gt;正如媒体所言，春运工作俨然成了中国人每年都不能回避的一场“硬仗”。每年交通部门都会“精心安排”，“积极备战”，后来都会“圆满完成旅客发送任务”。但毋庸讳言，春运在很多人脑海里留下的回忆却是“花了钱，遭了罪”。&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;有人认为，春运遭罪，根本上还是由于中国人多，“遭罪不可避免”！“不可避免论”似乎不无道理，但还是应该问一句，我们是否已经穷尽了一切办法？只要还有一丁点努力的空间，就请不要轻易说出“只能如此”的话来。&lt;/p&gt;

&lt;p&gt;教育部门是不是只能几乎“一刀切”的集中放寒假？铁路部门是不是只能让学校提前几个月订团体票？公安部门是不是对火车站周围嚣张的票贩子真的就束手无策？政府部门是不是一定都需要上班到除夕当晚才集体放假？买不到中转票的弱势旅客是不是只能在火车站广场上等待一天又一天？平日里一个又一个大型交易会都可以容纳的城市，是不是一定要将订票窗口开到冰天雪地的露天里？&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>转移网站空间，升级 BO-BLOG</title>
    <link href="/host-transfer-and-update-bo-blog/"/>
    <updated>2006-01-14T19:47:05+08:00</updated>
    <id>/host-transfer-and-update-bo-blog</id>
    <content type="html">&lt;p&gt;转移到新的网站空间上，如果你收藏了 http://Yonsm.reg365.com，请更新为 &lt;a href=&quot;/&quot;&gt;HTTP://WWW.Yonsm.NET&lt;/a&gt;。 感谢好友 Yicho 提供的有快又好用的 PHP 空间。 同时，感谢 vBin 为我提供了 1 年多的 BLOG 空间。 如果想访问老的绿色风格的 BLOG，请访问：http://Yonsm.reg365.com/index.php。旧的模版风格我个人认为非常好看，只是暂时还没有时间去做 2.0 的模版，过段时间应该会做吧。&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>DetourQQ 2.4.18 源代码</title>
    <link href="/detourqq-code/"/>
    <updated>2004-11-06T20:36:04+08:00</updated>
    <id>/detourqq-code</id>
    <content type="html">&lt;p&gt;下载: &lt;a href=&quot;/assets/1099686627.rar&quot;&gt;DetourQQ 2.4.18.68&lt;/a&gt; (63K)&lt;/p&gt;

&lt;p&gt;使用 CodeAtom 通用内存补丁引擎，支持模糊搜索、批量补丁等功能，非常方便编写内存补丁，有兴趣的可以看看源代码。&lt;/p&gt;

&lt;p&gt;工程文件是 Visual Studio .NET 的，VC6 中也可以建立工程并编译通过，但是需要安装新的 Platform SDK。&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>域名更换</title>
    <link href="/domain-name-change/"/>
    <updated>2004-11-05T11:20:07+08:00</updated>
    <id>/domain-name-change</id>
    <content type="html">&lt;p&gt;弄了个更好记的域名: &lt;a href=&quot;http://Yonsm.zj.com&quot;&gt;Yonsm.zj.com&lt;/a&gt;，因为我就在浙江杭州，所以这个域名也比较名副其实，呵呵~~&lt;/p&gt;

&lt;p&gt;已收藏 &lt;a href=&quot;http://Yonsm.reg365.com&quot;&gt;Yonsm.reg365.com&lt;/a&gt; 的朋友请更新收藏夹。&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>选举！又见选举！！</title>
    <link href="/the-election-in-taiwan/"/>
    <updated>2004-11-04T10:56:01+08:00</updated>
    <id>/the-election-in-taiwan</id>
    <content type="html">&lt;p&gt;杨过说羊祜说过一句话——“天下不如意事，十常居七八”，每次希望赢得大选的人总是选不上。&lt;/p&gt;

&lt;p&gt;从 2000 年台湾的宋连匾许敖，到 2001 年底的立法会选举，再到 2004 年的 320，还有现在现在的驴象之争，没有一次是我所希望的结果……稍有安慰的一次，就是前段时间香港立法会了，但恐怕也是……&lt;/p&gt;

&lt;p&gt;哎！天下不如意事，十常居七八……&lt;/p&gt;

&lt;p&gt;嘿嘿~~自己又没投票权，这么热心干哈呀……&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  
  <entry>
    <title>构造一个方便高效 INI 类</title>
    <link href="/a-convenient-and-efficient-ini-class/"/>
    <updated>2004-11-02T11:49:02+08:00</updated>
    <id>/a-convenient-and-efficient-ini-class</id>
    <content type="html">&lt;p&gt;   Windows API 本身已经为我们写好了操作 INI 的函数，但是有时候用起来可能不是很方便。把这些 API 简单封装一下，将会大大方便我们读写 INI 文件。&lt;/p&gt;

&lt;p&gt;    网上 INI 类多如牛毛。不过我个人认为，实在没有必要每个 INI 操作都真的去调用 INI 类中的函数。下面看看我写的充分使用 inline 和 C++ 省却参数构造的 CIni 类:&lt;!-- more --&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;// 预处理&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;#pragma once&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;#include &amp;lt;windows.h&amp;gt;&amp;lt;/windows.h&amp;gt;

#define INI_Main TEXT(&quot;Main&quot;)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;// CIni 类&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;class CIni&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;{&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;public:&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    // INI 文件名&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    TCHAR m_tzFileName[MAX_PATH];

public:&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    // 初始化配置文件&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    inline CIni()&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;        GetModuleFileName(NULL, m_tzFileName, MAX_PATH);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;        lstrcpy(m_tzFileName + lstrlen(m_tzFileName) - 4, TEXT(&quot;.ini&quot;));&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    }

    // 初始化配置文件&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    inline CIni(PCTSTR ptzFileName)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;        lstrcpy(m_tzFileName, ptzFileName);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    }

    // 获取整数&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    inline UINT GetInt(PCTSTR ptzKeyName, INT iDefault = 0, PCTSTR ptzSectionName = INI_Main)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;        return GetPrivateProfileInt(ptzSectionName, ptzKeyName, iDefault, m_tzFileName);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    }

    // 设置整数&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    inline BOOL SetInt(PCTSTR ptzKeyName, INT iValue = 0, PCTSTR ptzSectionName = INI_Main)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;        TCHAR tzString[16];

        wsprintf(tzString, TEXT(&quot;%d&quot;), iValue);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;        return WritePrivateProfileString(ptzSectionName, ptzKeyName, tzString, m_tzFileName);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    }

    // 获取字符串&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    inline DWORD GetString(PCTSTR ptzKeyName, PTSTR ptzReturnedString,&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;        DWORD dwSize = MAX_PATH, PCTSTR ptzDefault = NULL, PCTSTR ptzSectionName = INI_Main)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;        return GetPrivateProfileString(ptzSectionName, ptzKeyName, ptzDefault, ptzReturnedString,&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;            dwSize, m_tzFileName);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    }

    // 设置字符串&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    inline BOOL SetString(PCTSTR ptzKeyName, PCTSTR ptzString = NULL, PCTSTR ptzSectionName = INI_Main)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;        return WritePrivateProfileString(ptzSectionName, ptzKeyName, ptzString, m_tzFileName);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    }

    // 获取结构&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    inline BOOL GetStruct(PCTSTR ptzKeyName, PVOID pvStruct, UINT uSize, PCTSTR ptzSectionName = INI_Main)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;        return GetPrivateProfileStruct(ptzSectionName, ptzKeyName, pvStruct, uSize, m_tzFileName);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    }

    // 设置结构&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    inline BOOL SetStruct(PCTSTR ptzKeyName, PVOID pvStruct, UINT uSize, PCTSTR ptzSectionName = INI_Main)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;        return WritePrivateProfileStruct(ptzSectionName, ptzKeyName, pvStruct, uSize, m_tzFileName);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    }

    // 获取节&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    inline DWORD GetSection(PTSTR ptzReturnBuffer, DWORD dwSize, PCTSTR ptzSectionName = INI_Main)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;        return GetPrivateProfileSection(ptzSectionName, ptzReturnBuffer, dwSize, m_tzFileName);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    }

    // 设置节&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    inline DWORD SetSection(PCTSTR ptzString, PCTSTR ptzSectionName = INI_Main)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;        return WritePrivateProfileSection(ptzSectionName, ptzString, m_tzFileName);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    }

    // 获取节名&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    inline DWORD GetSectionNames(PTSTR ptzReturnBuffer, DWORD dwSize)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;        return GetPrivateProfileSectionNames(ptzReturnBuffer, dwSize, m_tzFileName);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;};&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;    一个 INI 文件为一个 CIni 对象。使用举例如下: &lt;/p&gt;

&lt;p&gt;    CIni iniMain;   // 使用默认 INI 名称，即与 EXE 仅仅是扩展名不同。&lt;/p&gt;

&lt;p&gt;    CIni iniSel(TEXT(&quot;F:Sel.ini&quot;)); // 指定 INI 路径&lt;/p&gt;

&lt;p&gt;    TCHAR tzText[MAX_PATH];&lt;br/&gt;
    COLORREF crTextColor;&lt;/p&gt;

&lt;p&gt;    crTextColor = iniMain.GetInt(INI_TextColor);&lt;br/&gt;
    iniMain.SetInt(INI_TextColor, crTextColor);&lt;br/&gt;
    iniMain.GetString(INI_PicturesPath, tzText);&lt;br/&gt;
    iniMain.SetString(INI_PicturesPath, TEXT(&quot;F:My Pictures&quot;));&lt;br/&gt;
    iniSel.SetStruct(INI_WindowRect, &amp;amp;rtWindow, sizeof(RECT));&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;    当然，如果一个程序中只操作一个 INI 文件，这个类也可以改成静态类 (只要在每个函数和变量前加上 static，非常简单)。&lt;/p&gt;

&lt;p&gt;下载: &lt;a href=&quot;http://yonsm.reg365.com/up/1099311280.rar&quot;&gt;CIni&lt;/a&gt;&lt;/p&gt;
</content>
    <summary type="html">Liquid error: undefined method `gsub' for nil:NilClass</summary>
  </entry>
  

</feed>
